---
title: "Coding for slope direction"
format: gfm
editor: visual
---

Taking the secreted peptidase results, we want to code them for slope direction (so negative slopes have one color, and positive slopes another). 

```{r setup, message=FALSE}
library(tidyverse)
theme_set(theme_classic())
d <- read_csv("../data/new_summary_of_all_results.csv")
# give your results files more meaningful names! You will have more results later!
glimpse(d)
```
Let's recode `DDG` as to whether the delta G (`total_energy`) is greater or smaller in the deep sample compared to the surface sample. We'll use the tidyverse `group_by()` function to separate our data frame into different groups, for each unique value of `paired`, and perform an operation on each group. 

I'll write a little function that will return a character vector of length 2, containing "negative", "positive", or "zero" depending on the relative value of the folding energy in deep vs surface sediments. 

```{r}
code_slope <- function(depths, energies) {
  # Input length should be exactly 2: one surface and one deep protein
  if(length(depths) != 2) {
    warning(paste("length of depth input vector is ", length(depths), "; expected length is 2"))
  }
  
  # Calculate "delta delta G" and then test its sign
  # I imagine there is a nice way to abstract out the depth names, 
  # so that you can pass depths as an argument
  DDG <- energies[depths=="15 mbsf"] - energies[depths == "0.25 mbsf"]
  
  # There's probably a more elegant way to do this, but I can't think of it
  if(DDG < 0) {
    slope <- "negative"
  } else if(DDG > 0) {
    slope <- "positive"
  } else if(DDG == 0) {
    slope <- "zero"
  } else {
    slope <- NA
  }
  # The return needs to be of length 2
  slope <- rep(slope, 2)
  slope # In R, stating the return value of a function causes it to auto-print
}
```
This function relies on there being exactly two proteins for each "pair", so let's check to make sure that's true:

```{r}
unpaired <- d %>%
  select(paired) %>% # no need for all those other columns
  group_by(paired) %>%
  summarise(n = n()) %>%
  filter(n != 2) 
head(unpaired)
```
Hmm. Not sure why there are two unpaired values, but for now we can just remove them and apply our function. 

```{r}
df <- d %>%
  anti_join(unpaired, by="paired") %>% # removes all rows of d that exist in unpaired
  group_by(paired) %>%
  mutate(DDG = code_slope(depths=depth, energies=total_energy))
```

Now we can plug this into the plotting function that I wrote previously (and which I have now hived off into its own function. I feel like it would make sense to build a package for some of these operations). 
```{r}
source("../R/ddg_plot.R")
ddg_plot(df, legend.pos = "right")
```
This plot is a little more ambiguous than previous ones, so let's do some more analysis. 

```{r, message=FALSE}
direction_table <- df %>%
  filter(depth=="0.25 mbsf") %>% # Just so we're not double-counting
  group_by(DDG) %>%
  summarise(n = n())
knitr::kable(direction_table)
```

So more negatives than positives. Let's do the paired t test. For that, we'll want to calculate the differences between the folding energies by depth.

```{r, message=FALSE}
depth_difs <- df %>%
  group_by(paired, DDG) %>%
  summarise(DDG.numeric = total_energy[depth=="15 mbsf"] - total_energy[depth=="0.25 mbsf"])
ggplot(depth_difs, aes(x=DDG.numeric)) + 
  geom_density() + 
  geom_rug(aes(color=DDG)) + 
  geom_vline(xintercept=0, colour="gray50") + 
  scale_color_manual(values = c("#517C96", "#8D2048"))
```
These are distributed normally (ish), so it is appropriate (ish) to do a parametric paired t-test.

```{r}
df <- df %>% arrange(paired)
surf <- df %>%
  filter(depth == "0.25 mbsf") %>%
  pull(total_energy)
deep <- df %>% 
  filter(depth == "15 mbsf") %>%
  pull(total_energy)
t.test(surf, deep, paired=TRUE, var.equal = TRUE)
```

Hmm. I'm not sure this is correct: almost 3 times more differences are negative than positive, which seems reasonably unlikely if there is no true difference between surface and deep. However it is about time to put my kids to bed, so I can't look into this further.  